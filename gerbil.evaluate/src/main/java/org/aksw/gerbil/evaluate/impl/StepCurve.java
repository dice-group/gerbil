package org.aksw.gerbil.evaluate.impl;

import javax.annotation.concurrent.NotThreadSafe;

/**
 * A step-wise implementation of a Curve
 *
 */
@NotThreadSafe
public class StepCurve extends Curve{
    private DIRECTION lastDir = null;
    private int trueStmts;
    private int falseStmts;
    private double stepLengthUp;
    private double stepLengthRight;
    private double upStepsCount = 0;
    private double rightStepsCount = 0;

    private enum DIRECTION {
        UP, RIGHT, DIAGONALLY
    };
    
    public StepCurve(Point start, Point last) {
		super(start, last);
	}

    public void defineStep(int trueStmts, int falseStmts) {
    	if (trueStmts == 0) {
            // FIXME throw Exception ?
        } else {
            stepLengthUp = 1.0 / trueStmts;
        }
        if (falseStmts == 0) {
            // FIXME throw Exception ?
        } else {
            stepLengthRight = 1.0 / falseStmts;
        }
        this.trueStmts = trueStmts;
        this.falseStmts = falseStmts;
    }


    /**
     * Adds a new point to the curve by going one step up.
     */
    public void addUp() {
        ++upStepsCount;
        double newY = 0.0;
        if (upStepsCount >= trueStmts) {
            // We want to end up at 1.0 so simply add it instead of trying to
            // calculate it
            // and end up with 0.999...
            newY = 1.0;
        } else {
            newY = upStepsCount * stepLengthUp;
        }
        addUp(newY);
    }

    /**
     * Adds a new point in the upper direction with the given Y value and the X
     * value of the last point. If the last point has already been set using a
     * step up, this point is reused instead of creating a new point.
     * 
     * @param newY
     *            the y value of the new point
     */
    private void addUp(double newY) {
        double lastX = 0.0;
        if (!points.isEmpty()) {
            Point last = points.get(points.size() - 1);
            lastX = last.x;
            if (DIRECTION.UP.equals(lastDir)) {
                last.setLocation(lastX, newY);
                return;
            }
        }
        Point newP = new Point();
        newP.setLocation(lastX, newY);
        points.add(newP);
        lastDir = DIRECTION.UP;
    }

    /**
     * Adds a new point to the curve by going one step right.
     */
    public void addRight() {
        double newX;
        ++rightStepsCount;
        if (rightStepsCount >= falseStmts) {
            // We want to end up at 1.0 so simply add it instead of trying to
            // calculate it
            // and end up with 0.999...
            newX = 1.0;
        } else {
            newX = rightStepsCount * stepLengthRight;
        }
        addRight(newX);
    }

    /**
     * Adds a new point in the right direction with the given X value and the Y
     * value of the last point. If the last point has already been set using a
     * step to the right, this point is reused instead of creating a new point.
     * 
     * @param newX
     *            the x value of the new point
     */
    private void addRight(double newX) {
        double lastY = 0.0;
        if (!points.isEmpty()) {
            Point last = points.get(points.size() - 1);
            lastY = last.y;
            if (DIRECTION.RIGHT.equals(lastDir)) {
                last.setLocation(newX, lastY);
                return;
            }
        }
        Point newP = new Point();
        newP.setLocation(newX, lastY);
        points.add(newP);
        lastDir = DIRECTION.RIGHT;
    }

    /**
     * Finish the curve by adding missing points (if the curve has not reached
     * the point (1,1) until now). The missing points are generated by making a
     * step to the right to x=1.0 and a step up to y=1.0, i.e., the missing
     * elements that have not been counted won't increase the AUC of the curve.
     */
    @Override
    public void finishCurve() {
        if (points.isEmpty()) {
            points.add(last);
        } else {
            last = points.get(points.size() - 1);
        }
        if (last.x < 1.0) {
            addRight(1.0);
        }
        if (last.y < 1.0) {
            addUp(1.0);
        }
    }

    public void addDiagonally(int stepsUp, int stepsRight) {
        // If we start with a triangle we have to add (0,0)
        Point last;
        if (points.isEmpty()) {
            last = new Point(0,0);
            points.add(last);
        } else {
            last = points.get(points.size() - 1);
        }
        double x = 0.0;
        rightStepsCount += stepsRight;
        if (rightStepsCount >= falseStmts) {
            // We want to end up at 1.0 so simply add it instead of trying to
            // calculate it and end up with 0.999...
            x = 1.0;
        } else {
            x = last.x + stepsRight * stepLengthRight;
        }
        double y = 0.0;
        upStepsCount += stepsUp;
        if (upStepsCount >= trueStmts) {
            // We want to end up at 1.0 so simply add it instead of trying to
            // calculate it and end up with 0.999...
            y = 1.0;
        } else {
            y = last.y + stepsUp * stepLengthUp;
        }
        points.add(new Point(x, y));
        lastDir = DIRECTION.DIAGONALLY;
    }

}
